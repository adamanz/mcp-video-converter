Directory structure:
└── mk2112-any_to_any.py/
    ├── README.md
    ├── any_to_any.py
    ├── CODE_OF_CONDUCT.md
    ├── launcher.py
    ├── LICENSE
    ├── requirements.txt
    ├── web_to_any.py
    ├── img/
    ├── modules/
    │   ├── category.py
    │   ├── prog_logger.py
    │   └── watchdog_handler.py
    ├── static/
    │   ├── css/
    │   │   └── style.css
    │   └── js/
    │       └── main.js
    ├── templates/
    │   └── index.html
    ├── tests/
    │   ├── __init__.py
    │   ├── test_cli.py
    │   ├── test_conversion_methods.py
    │   ├── test_core.py
    │   ├── test_edge_cases.py
    │   ├── test_fixtures.py
    │   ├── test_integration_and_routing.py
    │   ├── test_logging_progress.py
    │   └── test_merge_concat.py
    └── .github/
        ├── ISSUE_TEMPLATE/
        │   ├── bug_report.md
        │   └── feature_request.md
        └── workflows/
            └── test.yml

================================================
FILE: README.md
================================================
# any_to_any.py - Media File Converter, Merger, Concatenator

- Convert between a wide range of media formats (audio, video, image, document).
- Merge video files with separate audio files.
- Extract audio tracks from video files.
- Concatenate multiple files of the same type (audio, video, images).
- Process single files, entire directories (recursively if desired), or multiple specified inputs.
- Merge or concatenate files within individual directories or across multiple directories.
- Offering both a user-friendly Web Interface or a flexible Command Line Interface.
- Control output quality and video framerate during conversion.
- Automatically monitor a "dropzone" directory for new files and process them as they are dropped.
- Optionally delete source files upon successful processing.

![screenshot](./img/Any-to-Any-Web.png)

## Setup
1. **Clone/Download**:
   - Use `git clone` or download this repository
2. **Python Version**:
   - Ensure you have Python `3.10.x` or higher installed
3. **Install Dependencies**:
   - Open a terminal from inside the repository and run: `pip install -r requirements.txt`
4. **Running the Script**:
   Use Any_to_Any.py in either of two ways (click for details):
   - [*Web Interface*](#web-interface)
   - [*Command Line Interface*](#command-line-interface)

## Web Interface
- Start the web interface: `python any_to_any.py -w`
- Access the web view at `http://localhost:5000` via your browser
- Stop the web interface by pressing `CTRL+C` in the terminal

## Command Line Interface
You can structure a command in three fundamental ways:
- [**Single File Processing**](#single-file-processing)
   - You can convert,
   - You can't merge or concatenate with only one file.
- [**Directory Processing**](#directory-processing)
   - You can convert,
   - You can merge and concatenate files, if multiple are present.
- [**Multi Directory/File Processing**](#multi-directoryfile-processing)
   - You can convert,
   - You can merge or concatenate per input directory, or across them.

### Parameters

| Command Argument             | Meaning |
| ---------------------------- | ------- |
| `-h` or </br>`--help`        | List all available parameters, their description and default values, then exit. |
| `-i` or </br>`--input`       | Path to file itself or directory containing files to be converted. If not provided, the directory from where the script is called will be used. |
| `-f` or </br>`--format`      | Desired output file format, either `mp2`, `mp3`, `flac`, `wav`, `aac`, `aiff`, `ogg`, `oga`, `m4a`, `ac3`, `dts`, `weba`, `wma`, `mka`, `wv`, `caf`, `tta`, `m4b`, `eac3`, `spx`, `au`, `opus`, `m3u8`, `w64`, `mlp`, `adts`, `sbc`, `thd`, `jpg`, `png`, `gif`, `bmp`, `pdf`, `srt`, `webp`, `tiff`, `tga`, `eps`, `ps`, `ico`, `eps`, `jpeg2000`, `im`, `pcx`, `ppm`, `mp4`, `webm`, `mov`, `mkv`, `avi`, `wmv`, `flv`, `m2ts`, `3gp`, `3g2`, `mjpeg`, `asf`, `vob`, `ts`, `raw`, `mpg`, `mxf`, `drc`, `swf`, `f4v`, `m4v`, `mts`, `m2v`, `yuv`, movie codecs like `h263p`, `h264`, `h265`, `xvid`, `mpeg1`, `mpeg2`, `mpeg4`, `av1`, `avc`, `theora`, `vp8`, `vp9`, `hevc`, `prores`, `huffyuv`, `ffv1`, `ffvhuff`, `v210`, `v410`, `v308`, `v408`, `zlib`, `qtrle`, `snow`, `svq1`, `utvideo`, `cinepak`, `msmpeg4`, `h264_nvenc`, `vpx`, `h264_rgb`, `mpeg2video`, `prores_ks`, `vc2`, `flv1`, or protocols like `hls` and `dash` |
| `-o` or </br>`--output`      | Directory to save converted files into. Writing to the input file path, if none provided. |
| `-q` or </br>`--quality`     | Set output file quality, either `low`, `medium`, or `high`; default is same as input. |
| `-m` or </br>`--merge`       | Merge movie file with equally named audio file to become its audio track. |
| `-c` or </br>`--concat`      | Concatenate input files of the same type (images, audio, video) into one output file (e.g. `concatenated_video.mp4` for movie files, `concatenated_audio.mp3` for audio files). |
| `-a` or </br>`--across`      | Merge/Concatenate across directories when multiple directories are provided. |
| `-w` or </br>`--web`         | Ignores all other arguments, starts browser + a web server at `http://localhost:5000`. |
| `-d` or </br>`--delete`      | Delete input files after conversion. |
| `-r` or </br>`--recursive`   | Recursively process all input files in subdirectories from the input directory. Outputs by default will be placed in their respective subdirectory, unless different output path provided. |
| `-z` or </br>`--dropzone`    | While running, a specified directory will be monitored for new files. When a file is added, it will be converted to the specified format, saved in the output directory and deleted from the input directory. |
| `-fps` or</br>`--framerate`  | Set the framerate (fps) when converting to a movie format or codec; default maintains input fps. |

### Single File Processing
Convert a WEBP file to PNG:
```python
python any_to_any.py -i /path/to/file.webp -f png
```

Convert MP4 to MP3, delete the MP4 source file afterwards:
```python
python any_to_any.py -i /path/to/file.mp4 -f mp3 -d
```

Convert MP3 to M4A, set conversion quality to high, delete the MP3 source file afterwards:
```python
python any_to_any.py -i /path/to/file.mp3 -f m4a -q high -d
```

Convert MP4 to HLS streams:
```python
python any_to_any.py -i /path/to/file.mp4 -f hls
```
The option for `hls` creates a directory with distinct folders for stream fragments of resolutions `426x240`, `640x360`, `842x480`, `1280x720`, and `1920x1080`.

### Directory Processing
Directory Processing is useful when you want to work with multiple files in a directory

Convert all WEBP files in a directory to PNG:
```python
python any_to_any.py -i /path/to/webp-folder -f png
```

Convert all MP4 files to MP3, save to a different directory, set conversion quality to `high`, delete MP4 source files afterwards:
```python
python any_to_any.py -i /path/to/mp4-folder -o /path/to/save/folder -f mp3 -q high -d
```

Convert all MP3 files from any subdirectory **recursively** to M4A, delete MP3 source files afterwards:
```python
python any_to_any.py -i /path/to/mp3-top-folder -f m4a -d -r
```

Merge MP4 files with respective, equally named MP3 files in the same directory, save to a different directory, delete source files afterwards:
```python
python any_to_any.py -i /path/to/folder -o /path/to/save/folder -m -d
```

Concatenate MP4 files, save to a different directory, delete source files afterwards:
```python
python any_to_any.py -i /path/to/mp4-folder -o /path/to/save/folder -c -d
```

Setup a dropzone to monitor a directory for new files, convert them to MP3 and save them in the output directory (runs continuously, halt by pressing `CTRL+C`):
```python
python any_to_any.py -i /path/to/dropzone -o /path/to/save/folder -f mp3 -z
```

### Multi Directory/File Processing
You can also process multiple individual files or multiple directories at once.<br>
Note that only one output directory can be specified (omitting the `-o`/`--output` parameter works and will write to the input file paths).
```python
python any_to_any.py -i -1 /path/to/file1.mp4 -2 /path/to/mp4-folder -o /path/to/output-folder -f mp3
```
Merging across directories works when adding `-a`/`--across` to the `-m`/`--merge` parameter:
```python
python any_to_any.py -i -1 /path/to/folder1 -2 /path/to/folder2 -o /path/to/output-folder -m -a
```
Concatenating across directories works when adding `-a`/`--across` to the `-c`/`--concat` parameter:
```python
python any_to_any.py -i -1 /path/to/folder1 -2 /path/to/folder2 -o /path/to/output-folder -c -a
```
Omitting the `-a`/`--across` parameter will execute merges or concatenations seperately, per each input directory.

## Supported Formats
**Audio:** MP2, MP3, FLAC, AAC, AC3, DTS, OGG, OGA, WMA, WAV, M4A, AIFF, WEBA, MKA, WV, CAF, TTA, M4B, EAC3, SPX, AU, OPUS, M3U8, W64, MLP, ADTS, SBC, THD<br><br>
**Image:** JPG, PNG, GIF, BMP, WEBP, TIFF, TGA, EPS, PS, ICO, EPS, JPEG2000, IM, PCX, PPM<br><br>
**Document:** PDF, SRT<br><br>
**Video:** MP4, WEBM, MOV, MKV, AVI, WMV, FLV, MJPEG, M2TS, 3GP, 3G2, ASF, VOB, TS, RAW, MPG, MXF, DRC, SWF, F4V, M4V, MTS, M2V, YUV<br><br>
**Video Codec:** AV1, AVC, VP8, VP9, H263P, H264, H265, XVID, MPEG2, MPEG4, THEORA, MPEG1, HEVC, PRORES, HUFFYUV, FFV1, FFVHUFF, V210, V410, V308, V408, ZLIB, QTRLE, SNOW, SVQ1, UTVIDEO, CINEPAK, MSMPEG4, H264_NVENC, VPX; H264_RGB, MPEG2VIDEO, PRORES_KS, VC2, FLV1<br><br>
**Protocols:** HLS, DASH

## Creating Executables

Executables for Windows and Linux can be built like so:
1. Install PyInstaller: `pip install pyinstaller`
2. For Windows/Linux: `pyinstaller --clean any_to_any_web.spec`

## License
This project is licensed under the MIT License.

## Contributions
Contributions and feedback are welcome. Feel free to open issues or pull requests.

## Disclaimer
This script is provided as-is, without any warranties or guarantees.<br>
Users are responsible for ensuring compliance with applicable laws and regulations.

## TODO
1. Integrate Web-UI with real progress indicators
2. Multi-language Support (English, German, French, Spanish, Italian, Portuguese, Russian, Chinese, Japanese, Korean for a first iteration)


================================================
FILE: any_to_any.py
================================================
import os
import fitz
import time
import PyPDF2
import logging
import argparse
import subprocess
import numpy as np
from PIL import Image
from pathlib import Path
from modules.category import Category
from watchdog.observers import Observer
from modules.prog_logger import ProgLogger
from modules.watchdog_handler import WatchDogFileHandler
from moviepy import (AudioFileClip, VideoFileClip, VideoClip,
                     ImageSequenceClip, ImageClip, concatenate_videoclips,
                     concatenate_audioclips, clips_array)

class AnyToAny:
    """
    Taking an input directory of mp4 files, convert them to a multitude of formats using moviepy.
    Interact with the script using the command line arguments defined at the bottom of this file.
    """

    def __init__(self):
        # Setting up progress logger
        self.prog_logger = ProgLogger()
        # Setting up event logger and format
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        self.event_logger = logging.getLogger(__name__)
        # Setting up a dictionary of supported formats and respective information
        self._supported_formats = {
            Category.AUDIO: {
                "mp3": "libmp3lame",
                "flac": "flac",
                "aac": "aac",
                "ac3": "ac3",
                "dts": "dts",
                "ogg": "libvorbis",
                "wma": "wmav2",
                "wav": "pcm_s16le",
                "m4a": "aac",
                "aiff": "pcm_s16le",
                "weba": "libopus",
                "mka": "libvorbis",
                "wv": "wavpack",
                "tta": "tta",
                "m4b": "aac",
                "eac3": "eac3",
                "spx": "libvorbis",
                "mp2": "mp2",
                "caf": "pcm_s16be",
                "au": "pcm_s16be",
                "oga": "libvorbis",
                "opus": "libopus",
                "m3u8": "pcm_s16le",
                "w64": "pcm_s16le",
                "mlp": "mlp",
                "adts": "aac",
                "sbc": "sbc",
                "thd": "truehd",
            },
            Category.IMAGE: {
                "gif": self.to_gif,
                "png": self.to_frames,
                "jpg": self.to_frames,
                "bmp": self.to_bmp,
                "webp": self.to_webp,
                "tiff": self.to_frames,
                "tga": self.to_frames,
                "ps": self.to_frames,
                "ico": self.to_frames,
                "eps": self.to_frames,
                "jpeg2000": self.to_frames,
                "im": self.to_frames,
                "pcx": self.to_frames,
                "ppm": self.to_frames,
            },
            Category.DOCUMENT: {
                "pdf": self.to_frames,
                "srt": self.to_subtitles,
            },
            Category.MOVIE: {
                "webm": "libvpx",
                "mov": "libx264",
                "mkv": "libx264",
                "avi": "libx264",
                "mp4": "libx264",
                "wmv": "wmv2",
                "flv": "libx264",
                "mjpeg": "mjpeg",
                "m2ts": "mpeg2video",
                "3gp": "libx264",
                "3g2": "libx264",
                "asf": "wmv2",
                "vob": "mpeg2video",
                "ts": "hevc",
                "raw": "rawvideo",
                "mpg": "mpeg2video",
                "mxf": "mpeg2video",
                "drc": "libx265",
                "swf": "flv",
                "f4v": "libx264",
                "m4v": "libx264",
                "mts": "mpeg2video",
                "m2v": "mpeg2video",
                "yuv": "rawvideo",
            },
            Category.MOVIE_CODECS: {
                "av1": ["libaom-av1", "mkv"],  # [lib, fallback]
                "avc": ["libx264", "mp4"],
                "vp9": ["libvpx-vp9", "mp4"],
                "h265": ["libx265", "mkv"],
                "h264": ["libx264", "mkv"],
                "h263p": ["h263p", "mkv"],
                "xvid": ["libxvid", "mp4"],
                "mpeg4": ["mpeg4", "mp4"],
                "theora": ["libtheora", "ogv"],
                "mpeg2": ["mpeg2video", "mp4"],
                "mpeg1": ["mpeg1video", "mp4"],
                "hevc": ["libx265", "mkv"],
                "prores": ["prores", "mkv"],
                "vp8": ["libvpx", "webm"],
                "huffyuv": ["huffyuv", "mkv"],
                "ffv1": ["ffv1", "mkv"],
                "ffvhuff": ["ffvhuff", "mkv"],
                "v210": ["v210", "mkv"],
                "v410": ["v410", "mkv"],
                "v308": ["v308", "mkv"],
                "v408": ["v408", "mkv"],
                "zlib": ["zlib", "mkv"],
                "qtrle": ["qtrle", "mkv"],
                "snow": ["snow", "mkv"],
                "svq1": ["svq1", "mkv"],
                "utvideo": ["utvideo", "mkv"],
                "cinepak": ["cinepak", "mkv"],
                "msmpeg4": ["msmpeg4", "mkv"],
                "h264_nvenc": ["h264_nvenc", "mp4"],
                "vpx": ["libvpx", "webm"],
                "h264_rgb": ["libx264rgb", "mkv"],
                "mpeg2video": ["mpeg2video", "mpg"],
                "prores_ks": ["prores_ks", "mkv"],
                "vc2": ["vc2", "mkv"],
                "flv1": ["flv", "flv"],
            },
            Category.PROTOCOLS: {
                "hls": ["hls", "mkv"],
                "dash": ["dash", "mkv"],
            },
        }

        # Used in CLI information output
        self.supported_formats = [
            format
            for formats in self._supported_formats.values()
            for format in formats.keys()
        ]

        self.web_flag = False # Indicates if the script is being run from the web interface
        self.web_host = None  # Host address for the web interface

    def _end_with_msg(self, exception: Exception, msg: str) -> None:
        # Single point of exit
        if exception is not None:
            self.event_logger.warning(msg)
            raise exception(msg)
        else:
            self.event_logger.info(msg)
            exit(1)

    def _audio_bitrate(self, format: str, quality: str) -> str:
        # Return bitrate for audio conversion
        # If formats allow for a higher bitrate, we shift our scale accordingly
        if format in [
            "flac",
            "wav",
            "aac",
            "aiff",
            "eac3",
            "dts",
            "au",
            "wv",
            "tta",
            "mlp",
        ]:
            return {
                "high": "500k",
                "medium": "320k",
                "low": "192k",
            }.get(quality, None)
        else:
            return {
                "high": "320k",
                "medium": "192k",
                "low": "128k",
            }.get(quality, None)

    def run(
        self,
        input_path_args: list,
        format: str,
        output: str,
        framerate: int,
        quality: str,
        merge: bool,
        concat: bool,
        delete: bool,
        across: bool,
        recursive: bool,
        dropzone: bool,
    ) -> None:
        # Main function, convert media files to defined formats
        # or merge or concatenate, according to the arguments
        input_paths = []
        input_path_args = (
            input_path_args
            if input_path_args is not None
            else [os.path.dirname(os.getcwd())]
        )

        self.across = across
        self.recursive = recursive

        for _, arg in enumerate(input_path_args):
            # Custom handling of multiple input paths
            # (e.g. "-1 path1 -2 path2 -n pathn")
            if arg.startswith("-") and arg[1:].isdigit():
                input_paths.append(arg[2:])
            else:
                try:
                    input_paths[-1] = (input_paths[-1] + f" {arg}").strip()
                except IndexError:
                    input_paths.append(arg)

        if len(input_paths) == 1:
            self.output = output if output is not None else input_paths[0]
        else:
            # len(input_paths) > 1
            if not across:
                self.output = output if output is not None else None
            else:
                self.output = (
                    output if output is not None else os.path.dirname(os.getcwd())
                )

        # Check if the output dir exists - Create it otherwise
        if self.output is not None and not os.path.exists(self.output):
            os.makedirs(self.output)

        # No format means no conversion (but maybe merge || concat)
        self.target_format = (format.lower() if format is not None else None)
        self.framerate = framerate  # Possibly no framerate means same as input
        self.delete = delete  # Delete mp4 files after conversion
        # Check if quality is set, if not, set it to None
        self.quality = (
            (quality.lower() if quality.lower() in ["high", "medium", "low"] else None)
            if quality is not None
            else None
        )

        # Merge movie files with equally named audio files
        self.merging = merge
        # Concatenate files of same type (img/movie/audio) back to back
        self.concatenating = concat

        file_paths = {}
        was_none = False
        found_files = False

        # Check if input paths are given
        for input_path in input_paths:
            input_path = os.path.abspath(input_path)
            file_paths = self._get_file_paths(input_path, file_paths)
            # Make self.input hold a directory
            if os.path.isfile(str(input_path)):
                self.input = os.path.dirname(input_path)
            else:
                self.input = input_path

            # If no output path set or derived by the script by now, throw an error
            if not self.output:
                self._end_with_msg(ValueError, "[!] Error: No output path provided while using multiple input paths.")

            # If output is just a file for whatever reason, turn it into directory
            if os.path.isfile(self.output):
                self.output = os.path.dirname(self.output)

            # Unify path formatting, still works like any other string
            self.input, self.output = Path(self.input), Path(self.output)

            # Cut setup for media conversion short, begin dropzone mode
            if dropzone:
                if self.input == self.output or self.input in self.output.parents:
                    self._end_with_msg(None, "[!] Error: Dropzone mode requires input and output to be distinctly different")
                self.event_logger.info(f"[+] Dropzone mode active. Press CTRL+C to halt. Watching: {self.input}")
                self.watchdropzone(self.input)
                return

            # What if that directory contains subdirectories?
            if self.recursive:
                # Check if there is any subdirectory in the input path
                if any(entry.is_dir() for entry in os.scandir(self.input)):
                    file_paths = {} # Reset, we go through everything again to be sure
                    # If the user set the recursive option, also scan every non-empty subdirectory
                    for root, _, files in os.walk(self.input):
                        # root should be a directory with >=1 file to be considered
                        file_paths = self._get_file_paths(root, file_paths)

            if not any(file_paths.values()):
                if len(input_paths) > 1:
                    self.event_logger.info(f"[!] No convertible media files in '{input_path}' - Skipping\n")
                else:
                    self._end_with_msg(None, f"[!] No convertible media files found in '{input_path}'")
                continue

            # If no output given, output is set to the input path
            if not across:
                if self.output is None or was_none:
                    self.output = os.path.dirname(input_path)
                    was_none = True
                self.process_file_paths(file_paths)
                found_files = len(file_paths) > 0 if not found_files else found_files
                file_paths = {}

        # If multiple input paths are given, yet no output, output is set to the first input path
        if across:
            if self.output is None:
                self.output = os.path.dirname(input_paths[0])
            self.process_file_paths(file_paths)

        # Check if file_paths is empty
        if across and len(file_paths) == 0 or not found_files:
            self.event_logger.warning("No convertible media files")
        self.event_logger.info("[+] Job Finished")

    def process_file_paths(self, file_paths: dict) -> None:
        # Check if value associated to format is tuple/string or function to call specific conversion
        if self.target_format in self._supported_formats[Category.MOVIE].keys():
            self.to_movie(
                file_paths=file_paths,
                format=self.target_format,
                codec=self._supported_formats[Category.MOVIE][self.target_format],
            )
        elif self.target_format in self._supported_formats[Category.AUDIO].keys():
            self.to_audio(
                file_paths=file_paths,
                format=self.target_format,
                codec=self._supported_formats[Category.AUDIO][self.target_format],
            )
        elif self.target_format in self._supported_formats[Category.MOVIE_CODECS].keys():
            self.to_codec(
                file_paths=file_paths,
                codec=self._supported_formats[Category.MOVIE_CODECS][self.target_format],
            )
        elif self.target_format in self._supported_formats[Category.IMAGE].keys():
            self._supported_formats[Category.IMAGE][self.target_format](
                file_paths, self.target_format
            )
        elif self.target_format in self._supported_formats[Category.DOCUMENT].keys():
            self._supported_formats[Category.DOCUMENT][self.target_format](
                file_paths, self.target_format
            )
        elif self.target_format in self._supported_formats[Category.PROTOCOLS].keys():
            self.to_protocol(
                file_paths=file_paths,
                protocol=self._supported_formats[Category.PROTOCOLS][self.target_format],
            )
        elif self.merging:
            self.merge(file_paths, getattr(self, 'across', False))
        elif self.concatenating:
            self.concat(file_paths, self.target_format)
        else:
            # Handle unsupported formats here
            self._end_with_msg(
                ValueError,
                f"[!] Error: Output format must be one of {list(self.supported_formats)}",
            )

    def _get_file_paths(self, input: str, file_paths: dict = {}) -> dict:
        # Get media files from input directory
        def process_file(file_path: str) -> tuple:
            # Dissect "path/to/file.txt" into [path/to, file, txt]
            file_type = file_path.split(".")[-1].lower()
            file_name = os.path.basename(file_path)
            file_name = file_name[: file_name.rfind(".")]
            path_to_file = os.path.dirname(file_path) + os.sep
            return path_to_file, file_name, file_type

        def schedule_file(file_info: tuple) -> None:
            # If supported, add file to respective category schedule
            for category in self._supported_formats.keys():
                if file_info[2] in self._supported_formats[category]:
                    file_paths[category].append(file_info)
                    self.event_logger.info(f"[+] Scheduling: {file_info[1]}.{file_info[2]}")
                    break

        self.event_logger.info(f"[>] Scanning: {input}")

        # Check if file_paths is an empty dict
        if len(file_paths) == 0:
            file_paths = {category: [] for category in self._supported_formats}

        if input is not None and os.path.isfile(input):
            file_info = process_file(os.path.abspath(input))
            schedule_file(file_info)
        else:
            for directory in [input]:
                if not os.path.exists(directory):
                    self._end_with_msg(FileNotFoundError, f"[!] Error: Directory {directory} does not exist.")
            for file_name in os.listdir(input):
                file_path = os.path.abspath(os.path.join(input, file_name))
                file_info = process_file(file_path)
                schedule_file(file_info)
        return file_paths

    def watchdropzone(self, watch_path: str) -> None:
        # Watch a folder for new media files, process each as it arrives.
        watchdog_any = AnyToAny()

        # Setup a watchdog-specific AnyToAny instance
        # Link it to the current instance to share settings and loggers
        watchdog_any.target_format = self.target_format
        watchdog_any.output = self.output
        watchdog_any.framerate = self.framerate
        watchdog_any.quality = self.quality
        watchdog_any.merging = self.merging
        watchdog_any.concatenating = self.concatenating
        watchdog_any.delete = True
        watchdog_any.across = False
        watchdog_any.recursive = True
        watchdog_any.dropzone = False  # This one is not in dropzone mode
        watchdog_any.event_logger = self.event_logger
        watchdog_any.prog_logger = self.prog_logger
        
        event_handler = WatchDogFileHandler(watchdog_any)
        observer = Observer()
        observer.schedule(event_handler, watch_path, recursive=True)
        observer.start()

        try:
            while True:
                time.sleep(1) # Polling interval, adjust as needed
        except KeyboardInterrupt:
            observer.stop()
        observer.join()

    def _has_visuals(self, file_path_set: tuple) -> bool:
        try:
            VideoFileClip(self._join_back(file_path_set)).iter_frames()
            return True
        except Exception as _:
            pass
        return False

    def to_audio(self, file_paths: dict, format: str, codec: str) -> None:
        # Convert to audio
        # Audio to audio conversion
        for audio_path_set in file_paths[Category.AUDIO]:
            if audio_path_set[2] == format:
                continue
            audio = AudioFileClip(self._join_back(audio_path_set))
            # If recursive, create file outright where its source was found
            if not self.recursive or self.input != self.output:
                out_path = os.path.abspath(os.path.join(self.output, f"{audio_path_set[1]}.{format}"))
            else:
                out_path = os.path.abspath(os.path.join(audio_path_set[0], f"{audio_path_set[1]}.{format}"))
            # Write audio to file
            try:
                audio.write_audiofile(
                    out_path,
                    codec=codec,
                    bitrate=self._audio_bitrate(format, self.quality),
                    fps=audio.fps,
                    logger=self.prog_logger,
                )
            except Exception as _:
                self.event_logger.info(
                    "\n\n[!] Error: Source Sample Rate Incompatible With {format}: Trying Compatible Rate Instead...\n"
                )
                audio.write_audiofile(
                    out_path,
                    codec=codec,
                    bitrate=self._audio_bitrate(format, self.quality),
                    fps=48000,
                    logger=self.prog_logger,
                )
            audio.close()
            self._post_process(audio_path_set, out_path, self.delete)

        # Movie to audio conversion
        for movie_path_set in file_paths[Category.MOVIE]:
            out_path = os.path.abspath(
                os.path.join(self.output, f"{movie_path_set[1]}.{format}")
            )

            if self._has_visuals(movie_path_set):
                video = VideoFileClip(
                    self._join_back(movie_path_set), audio=True, fps_source="tbr"
                )
                audio = video.audio
                # Check if audio was found
                if audio is None:
                    self.event_logger.info(
                        f'[!] No audio found in "{self._join_back(movie_path_set)}" - Skipping\n'
                    )
                    video.close()
                    continue

                audio.write_audiofile(
                    out_path,
                    codec=codec,
                    bitrate=self._audio_bitrate(format, self.quality),
                    logger=self.prog_logger,
                )

                audio.close()
                video.close()
            else:
                try:
                    # AudioFileClip works for audio-only video files
                    audio = AudioFileClip(self._join_back(movie_path_set))
                    audio.write_audiofile(
                        out_path,
                        codec=codec,
                        bitrate=self._audio_bitrate(format, self.quality),
                        logger=self.prog_logger,
                    )
                    audio.close()
                except Exception as _:
                    self.event_logger.info(
                        f'[!] Failed to extract audio from audio-only file "{self._join_back(movie_path_set)}" - Skipping\n'
                    )
                    continue

            # Post process (delete mp4, print success)
            self._post_process(movie_path_set, out_path, self.delete)

    def to_codec(self, file_paths: dict, codec: dict) -> None:
        # Convert movie to same movie with different codec
        for codec_path_set in file_paths[Category.MOVIE]:
            if not self.recursive or self.input != self.output:
                out_path = os.path.abspath(os.path.join(self.output, f"{codec_path_set[1]}_{self.target_format}.{codec[1]}"))
            else:
                out_path = os.path.abspath(os.path.join(codec_path_set[0], f"{codec_path_set[1]}.{format}"))
            if self._has_visuals(codec_path_set):
                video = VideoFileClip(self._join_back(codec_path_set), audio=True, fps_source="tbr")
                try:
                    video.write_videofile(
                        out_path,
                        codec=codec[0],
                        fps=video.fps if self.framerate is None else self.framerate,
                        audio=True,
                        logger=self.prog_logger,
                    )
                except Exception as _:
                    if os.path.exists(out_path):
                        # There might be some residue left, remove it
                        os.remove(out_path)
                    self.event_logger.info(
                        f"\n\n[!] Codec Incompatible with {codec_path_set[2]}: Trying Compatible Format {codec[1]} Instead...\n"
                    )

                    video.write_videofile(
                        out_path,
                        codec=codec[0],
                        fps=video.fps if self.framerate is None else self.framerate,
                        audio=True,
                        logger=self.prog_logger,
                    )
                video.close()
            else:
                # Audio-only video file
                audio = AudioFileClip(self._join_back(codec_path_set))

                # Create new VideoClip with audio only
                clip = VideoClip(
                    lambda t: np.zeros(
                        (16, 16, 3), dtype=np.uint8
                    ),  # 16 black pixels required by moviepy
                    duration=audio.duration,
                )
                clip = clip.set_audio(audio)
                clip.write_videofile(
                    out_path,
                    codec=codec[0],
                    fps=24 if self.framerate is None else self.framerate,
                    audio=True,
                    logger=self.prog_logger,
                )

                clip.close()
                audio.close()

            self._post_process(codec_path_set, out_path, self.delete)

    def to_movie(self, file_paths: dict, format: str, codec: str) -> None:
        # Convert to movie with specified format
        pngs = bmps = jpgs = []
        for image_path_set in file_paths[Category.IMAGE]:
            # Depending on the format, different fragmentation is required
            if image_path_set[2] == "gif":
                clip = VideoFileClip(self._join_back(image_path_set), audio=False)
                # If recursive, create file outright where its source was found
                if not self.recursive or self.input != self.output:
                    out_path = os.path.abspath(os.path.join(self.output, f"{image_path_set[1]}.{format}"))
                else:
                    out_path = os.path.abspath(os.path.join(image_path_set[0], f"{image_path_set[1]}.{format}"))
                clip.write_videofile(
                    out_path,
                    codec=codec,
                    fps=clip.fps if self.framerate is None else self.framerate,
                    audio=False,
                    logger=self.prog_logger,
                )
                clip.close()
                self._post_process(image_path_set, out_path, self.delete)
            elif image_path_set[2] == "png":
                pngs.append(ImageClip(self._join_back(image_path_set)).set_duration(1))
            elif image_path_set[2] == "jpg":
                jpgs.append(ImageClip(self._join_back(image_path_set)).set_duration(1))
            elif image_path_set[2] == "bmp":
                bmps.append(ImageClip(self._join_back(image_path_set)).set_duration(1))

        # Pics to movie
        for pics in [pngs, jpgs, bmps]:
            if len(pics) > 0:
                final_clip = concatenate_videoclips(pics, method="compose")
                out_path = os.path.abspath(
                    os.path.join(self.output, f"merged.{format}")
                )
                final_clip.write_videofile(
                    out_path,
                    fps=24 if self.framerate is None else self.framerate,
                    codec=codec,
                    logger=self.prog_logger,
                )
                final_clip.close()

        # Movie to different movie
        for movie_path_set in file_paths[Category.MOVIE]:
            if not movie_path_set[2] == format:
                out_path = os.path.abspath(
                    os.path.join(self.output, f"{movie_path_set[1]}.{format}")
                )
                if self._has_visuals(movie_path_set):
                    video = VideoFileClip(
                        self._join_back(movie_path_set), audio=True, fps_source="tbr"
                    )
                    video.write_videofile(
                        out_path,
                        codec=codec,
                        fps=video.fps if self.framerate is None else self.framerate,
                        audio=True,
                        logger=self.prog_logger,
                    )
                    video.close()
                else:
                    # Audio-only video file
                    audio = AudioFileClip(self._join_back(movie_path_set))

                    # Create new VideoClip with audio only
                    clip = VideoClip(
                        lambda t: np.zeros(
                            (16, 16, 3), dtype=np.uint8
                        ),  # 16 black pixels required by moviepy
                        duration=audio.duration,
                    )

                    clip = clip.set_audio(audio)

                    clip.write_videofile(
                        out_path,
                        codec=codec,
                        fps=24 if self.framerate is None else self.framerate,
                        audio=True,
                        logger=self.prog_logger,
                    )

                    clip.close()
                    audio.close()

                self._post_process(movie_path_set, out_path, self.delete)

    def to_protocol(self, file_paths: dict, protocol: list) -> None:
        # Convert movie files into adaptive streaming formats HLS (.m3u8) or DASH (.mpd).
        if protocol[0] not in list(self._supported_formats[Category.PROTOCOLS].keys()):
            print("\n", protocol, "\n")
            self._end_with_msg(None, f"Unsupported streaming protocol: {protocol[0]}")

        for movie_path_set in file_paths[Category.MOVIE]:
            input_file = os.path.abspath(self._join_back(movie_path_set))
            base_name = os.path.splitext(movie_path_set[-1])[0]
            current_out_dir = os.path.abspath(os.path.join(self.output, f"{base_name}_{protocol[0]}"))
            os.makedirs(current_out_dir, exist_ok=True)

            if protocol[0] == "hls":
                renditions = [("426x240", "400k", "64k"),
                              ("640x360", "800k", "96k"),
                              ("842x480", "1400k", "128k"),
                              ("1280x720", "2800k", "128k"),
                              ("1920x1080", "5000k", "192k")]
                variant_playlist = "#EXTM3U\n"
                cmd = ["ffmpeg", "-y", "-i", input_file]

                for i, (resolution, v_bitrate, a_bitrate) in enumerate(renditions):
                    os.makedirs(os.path.join(current_out_dir, f"{renditions[i][0]}"), exist_ok=True)
                    self.event_logger.info(f"[+] Creating HLS stream for {self._join_back(movie_path_set)}: {resolution} at {v_bitrate} video and {a_bitrate} audio")
                    stream = [
                        "-map", "0:v:0",
                        "-map", "0:a:0",
                        "-c:v", "h264",
                        "-b:v", v_bitrate,
                        "-s", resolution,
                        "-c:a", "aac",
                        "-b:a", a_bitrate,
                        "-hls_time", "4",
                        "-hls_playlist_type", "vod",
                        "-hls_segment_filename", os.path.join(os.path.join(current_out_dir, f"{renditions[i][0]}"), f"{renditions[i][0]}_%03d.ts"),
                        os.path.join(os.path.join(current_out_dir, f"{renditions[i][0]}"), f"{renditions[i][0]}.m3u8")
                    ]
                    cmd += stream
                    variant_playlist += f'#EXT-X-STREAM-INF:BANDWIDTH={int(v_bitrate[:-1]) * 1000},RESOLUTION={resolution}\n{i}.m3u8\n'
                self.event_logger.info(f"[+] Creating master playlist for HLS stream: {self._join_back(movie_path_set)}")
                master_playlist_path = os.path.join(current_out_dir, "master.m3u8")

                try:
                    self._run_command(cmd)
                    with open(master_playlist_path, "w") as f:
                        f.write(variant_playlist)
                    self._post_process(movie_path_set, master_playlist_path, self.delete)
                except Exception as e:
                    self._end_with_msg(None, f"Failed to create HLS: {e}")
            elif protocol[0] == "dash":
                self.event_logger.info(f"[+] Creating DASH stream for {self._join_back(movie_path_set)}")
                out_path = os.path.join(current_out_dir, "manifest.mpd")
                cmd = [
                    "ffmpeg",
                    "-y",
                    "-i", input_file,
                    "-map", "0",
                    "-b:v", "1500k",
                    "-c:v", "libx264",
                    "-c:a", "aac",
                    "-bf", "1",
                    "-keyint_min", "120",
                    "-g", "120",
                    "-sc_threshold", "0",
                    "-b_strategy", "0",
                    "-ar", "48000",
                    "-use_timeline", "1",
                    "-use_template", "1",
                    "-adaptation_sets", "id=0,streams=v id=1,streams=a",
                    "-f", "dash",
                    out_path
                ]
                try:
                    self._run_command(cmd)
                    self._post_process(movie_path_set, out_path, self.delete)
                except Exception as e:
                    self._end_with_msg(movie_path_set, f"Failed to create DASH: {e}")

    def _run_command(self, command: list) -> None:
        try:
            _ = subprocess.run(command,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE,
                                    check=True,
                                    text=True)
        except subprocess.CalledProcessError as e:
            error_msg = f"Failed: {' '.join(command)}\n\nSTDOUT:\n{e.stdout}\n\nSTDERR:\n{e.stderr}"
            raise RuntimeError(error_msg)

    def to_subtitles(self, file_paths: dict, format: str) -> None:
        for movie_path_set in file_paths[Category.MOVIE]:
            input_path = self._join_back(movie_path_set)
            out_path = os.path.abspath(os.path.join(self.output, f"{movie_path_set[1]}.srt"))
            self.event_logger.info(f"[+] Extracting subtitles from '{input_path}'")
            try:
                # Use FFmpeg to extract subtitles
                _ = subprocess.run(["ffmpeg",
                                    "-i",
                                    input_path,
                                    "-map",
                                    "0:s:0",  # Selects first subtitle stream
                                    "-c:s",
                                    "srt",
                                    out_path],
                    capture_output=True,
                    text=True,
                )

                if os.path.exists(out_path) and os.path.getsize(out_path) > 0:
                    self.event_logger.info(f"[+] Subtitles successfully extracted to '{out_path}'")
                    self._post_process(
                        movie_path_set, out_path, self.delete, show_status=False
                    )
                else:
                    # Try extracting closed captions when direct extract fails (found mostly in MP4 and MKV)
                    self.event_logger.info(
                        "[!] No dedicated subtitle track found. Trying to extract embedded text..."
                    )
                    _ = subprocess.run(
                        ["ffmpeg", "-i", input_path, "-c:s", format, out_path],
                        capture_output=True,
                        text=True,
                    )
                    if os.path.exists(out_path) and os.path.getsize(out_path) > 0:
                        self.event_logger.info(
                            f"[+] Embedded subtitles successfully extracted to '{out_path}'"
                        )
                        self._post_process(
                            movie_path_set, out_path, self.delete, show_status=False
                        )
                    else:
                        self.event_logger.info(f"[!] No subtitles found for '{input_path}'")
            except Exception as e:
                self.event_logger.info(f"[!] Extraction of subtitles failed: {str(e)}")
                try:
                    subprocess.run(["ffmpeg", "-version"], capture_output=True)
                except FileNotFoundError:
                    self.event_logger.info(
                        "[!] FFmpeg not found. Install FFmpeg to extract subtitles."
                    )
                    break

    def to_frames(self, file_paths: dict, format: str) -> None:
        # Converting to image frame sets
        # This works for images and movies only
        for image_path_set in file_paths[Category.IMAGE]:
            if image_path_set[2] == format:
                continue
            if image_path_set[2] == "gif":
                clip = ImageSequenceClip(self._join_back(image_path_set), fps=24)
                for _, frame in enumerate(
                    clip.iter_frames(fps=clip.fps, dtype="uint8")
                ):
                    frame_path = os.path.abspath(
                        os.path.join(
                            self.output,
                            f"{image_path_set[1]}-%{len(str(int(clip.duration * clip.fps)))}d.{format}",
                        )
                    )
                    Image.fromarray(frame).save(frame_path, format=format)
                clip.close()
                self._post_process(image_path_set, self.output, self.delete)
            else:
                if not os.path.exists(os.path.join(self.output, image_path_set[1])):
                    self.output = self.input
                img_path = os.path.abspath(
                    os.path.join(self.output, f"{image_path_set[1]}.{format}")
                )
                with Image.open(self._join_back(image_path_set)) as img:
                    img.convert("RGB").save(img_path, format=format)
                self._post_process(image_path_set, img_path, self.delete)

        for doc_path_set in file_paths[Category.DOCUMENT]:
            if doc_path_set[2] == format:
                continue
            if not os.path.exists(os.path.join(self.output, doc_path_set[1])):
                try:
                    os.makedirs(os.path.join(self.output, doc_path_set[1]))
                except OSError as e:
                    self.event_logger.info(f"[!] Error: {e} - Setting output directory to {self.input}")
                    self.output = self.input

            if doc_path_set[2] == "pdf":
                # Per page, convert pdf to image
                pdf_path = self._join_back(doc_path_set)
                pdf = PyPDF2.PdfReader(pdf_path)
                img_path = os.path.abspath(
                    os.path.join(
                        os.path.join(self.output, doc_path_set[1]),
                        f"{doc_path_set[1]}-%{len(str(len(pdf.pages)))}d.{format}",
                    )
                )

                try:
                    os.makedirs(os.path.dirname(img_path), exist_ok=True)
                    self.output = os.path.dirname(img_path)
                except OSError as e:
                    self.event_logger.info(f"[!] Error: {e} - Setting output directory to {self.input}")
                    self.output = self.input

                pdf_document = fitz.open(pdf_path)

                for page_num in range(len(pdf_document)):
                    pix = pdf_document[page_num].get_pixmap()
                    img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                    img_file = img_path % (page_num + 1)
                    img.save(img_file, format.upper())

                pdf_document.close()
                self._post_process(doc_path_set, img_path, self.delete)

        # Audio cant be image-framed, movies certrainly can
        for movie_path_set in file_paths[Category.MOVIE]:
            if movie_path_set[2] not in self._supported_formats[Category.MOVIE]:
                self.event_logger.info(f"[!] Unsupported movie format: {movie_path_set[2]} - Skipping")
                continue
            if self._has_visuals(movie_path_set):
                video = VideoFileClip(
                    self._join_back(movie_path_set), audio=False, fps_source="tbr"
                )
                if not os.path.exists(os.path.join(self.output, movie_path_set[1])):
                    try:
                        os.makedirs(os.path.join(self.output, movie_path_set[1]))
                    except OSError as e:
                        self.event_logger.info(
                            f"[!] Error: {e} - Setting output directory to {self.input}"
                        )
                        self.output = self.input
                img_path = os.path.abspath(
                    os.path.join(
                        os.path.join(self.output, movie_path_set[1]),
                        f"{movie_path_set[1]}-%{len(str(int(video.duration * video.fps)))}d.{format}",
                    )
                )

                video.write_images_sequence(img_path, fps=video.fps, logger=self.prog_logger)
                video.close()
                self._post_process(movie_path_set, img_path, self.delete)
            else:
                self.event_logger.info(
                    f'[!] Skipping "{self._join_back(movie_path_set)}" - Audio-only video file'
                )

            if format == "pdf":
                # Merge all freshly created 1-page pdfs into one big pdf
                pdf_out_path = os.path.join(
                    self.output, movie_path_set[1], "merged.pdf"
                )
                pdfs = [
                    os.path.join(self.output, movie_path_set[1], file)
                    for file in os.listdir(os.path.join(self.output, movie_path_set[1]))
                    if file.endswith("pdf")
                ]
                self.event_logger.info(f"[+] Merging {len(pdfs)} PDFs into {pdf_out_path}")
                pdfs.sort()
                pdf_merger = PyPDF2.PdfMerger()
                for pdf in pdfs:
                    pdf_merger.append(pdf)
                pdf_merger.write(pdf_out_path)
                pdf_merger.close()
                for pdf in pdfs:
                    os.remove(pdf)
                self._post_process(movie_path_set, pdf_out_path, self.delete)
            else:
                self._post_process(movie_path_set, img_path, self.delete)

    def to_gif(self, file_paths: dict, format: str) -> None:
        # All images in the input directory are merged into one gif
        if len(file_paths[Category.IMAGE]) > 0:
            images = []
            for image_path_set in file_paths[Category.IMAGE]:
                if image_path_set[2] == format:
                    continue
                with Image.open(self._join_back(image_path_set)) as image:
                    images.append(image.convert("RGB"))
            images[0].save(
                os.path.join(self.output, f"merged.{format}"),
                save_all=True,
                append_images=images[1:],
            )

        # Movies are converted to gifs as well, retaining 1/3 of the frames
        for movie_path_set in file_paths[Category.MOVIE]:
            if self._has_visuals(movie_path_set):
                video = VideoFileClip(
                    self._join_back(movie_path_set), audio=False, fps_source="tbr"
                )
                gif_path = os.path.join(self.output, f"{movie_path_set[1]}.{format}")
                video.write_gif(gif_path, fps=video.fps // 3, logger=self.prog_logger)
                video.close()
                self._post_process(movie_path_set, gif_path, self.delete)
            else:
                self.event_logger.info(
                    f'[!] Skipping "{self._join_back(movie_path_set)}" - Audio-only video file'
                )

    def to_bmp(self, file_paths: dict, format: str) -> None:
        # Movies are converted to bmps frame by frame
        for movie_path_set in file_paths[Category.MOVIE]:
            if self._has_visuals(movie_path_set):
                video = VideoFileClip(
                    self._join_back(movie_path_set), audio=False, fps_source="tbr"
                )
                bmp_path = os.path.join(self.output, f"{movie_path_set[1]}.{format}")
                # Split video into individual bmp frame images at original framerate
                for _, frame in enumerate(
                    video.iter_frames(fps=video.fps, dtype="uint8")
                ):
                    frame.save(
                        f"{bmp_path}-%{len(str(int(video.duration * video.fps)))}d.{format}",
                        format=format,
                    )
                self._post_process(movie_path_set, bmp_path, self.delete)
            else:
                self.event_logger.info(
                    f'[!] Skipping "{self._join_back(movie_path_set)}" - Audio-only video file'
                )

        # Pngs and gifs are converted to bmps as well
        for image_path_set in file_paths[Category.IMAGE]:
            if image_path_set[2] == format:
                continue
            if image_path_set[2] in ["png", "jpg", "tiff", "tga", "eps"]:
                bmp_path = os.path.join(self.output, f"{image_path_set[1]}.{format}")
                with Image.open(self._join_back(image_path_set)) as img:
                    img.convert("RGB").save(bmp_path, format=format)
            elif image_path_set[2] == "gif":
                clip = VideoFileClip(self._join_back(image_path_set))
                for _, frame in enumerate(
                    clip.iter_frames(fps=clip.fps, dtype="uint8")
                ):
                    frame_path = os.path.join(
                        self.output,
                        f"{image_path_set[1]}-%{len(str(int(clip.duration * clip.fps)))}d.{format}",
                    )
                    Image.fromarray(frame).convert("RGB").save(
                        frame_path, format=format
                    )
            else:
                # Handle unsupported file types here
                self.event_logger.info(
                    f"[!] Skipping {self._join_back(image_path_set)} - Unsupported format"
                )

    def to_webp(self, file_paths: dict, format: str) -> None:
        # Convert frames in webp format
        # Movies are converted to webps, frame by frame
        for movie_path_set in file_paths[Category.MOVIE]:
            if self._has_visuals(movie_path_set):
                video = VideoFileClip(
                    self._join_back(movie_path_set), audio=False, fps_source="tbr"
                )
                if not os.path.exists(os.path.join(self.output, movie_path_set[1])):
                    try:
                        os.makedirs(os.path.join(self.output, movie_path_set[1]))
                    except OSError as e:
                        self.event_logger.info(
                            f"[!] Error: {e} - Setting output directory to {self.input}"
                        )
                        self.output = self.input
                img_path = os.path.abspath(
                    os.path.join(
                        os.path.join(self.output, movie_path_set[1]),
                        f"{movie_path_set[1]}-%{len(str(int(video.duration * video.fps)))}d.{format}",
                    )
                )
                video.write_images_sequence(img_path, fps=video.fps, logger=self.prog_logger)
                video.close()
                self._post_process(movie_path_set, img_path, self.delete)
            else:
                self.event_logger.info(
                    f'[!] Skipping "{self._join_back(movie_path_set)}" - Audio-only video file'
                )

        # Pngs and gifs are converted to webps as well
        for image_path_set in file_paths[Category.IMAGE]:
            if image_path_set[2] == format:
                continue
            if image_path_set[2] in ["png", "jpg", "tiff", "tga", "eps"]:
                webp_path = os.path.join(self.output, f"{image_path_set[1]}.{format}")
                with Image.open(self._join_back(image_path_set)) as img:
                    img.convert("RGB").save(webp_path, format=format)
            elif image_path_set[2] == "gif":
                clip = VideoFileClip(self._join_back(image_path_set))
                for _, frame in enumerate(
                    clip.iter_frames(fps=clip.fps, dtype="uint8")
                ):
                    frame_path = os.path.join(
                        self.output,
                        f"{image_path_set[1]}-%{len(str(int(clip.duration * clip.fps)))}d.{format}",
                    )
                    Image.fromarray(frame).convert("RGB").save(
                        frame_path, format=format
                    )
            else:
                # Handle unsupported file types here
                self.event_logger.info(
                    f"[!] Skipping {self._join_back(image_path_set)} - Unsupported format"
                )

    def concat(self, file_paths: dict, format: str) -> None:
        # Concatenate files of same type (img/movie/audio) back to back
        # Concatenate audio files
        if file_paths[Category.AUDIO] and (
            format is None or format in self._supported_formats[Category.AUDIO]
        ):
            concat_audio = concatenate_audioclips(
                [
                    AudioFileClip(self._join_back(audio_path_set))
                    for audio_path_set in file_paths[Category.AUDIO]
                ]
            )
            format = "mp3" if format is None else format
            audio_out_path = os.path.join(self.output, f"concatenated_audio.{format}")
            concat_audio.write_audiofile(
                audio_out_path,
                codec=self._supported_formats[Category.AUDIO][format],
                bitrate=self._audio_bitrate(format, self.quality)
                if self.quality is not None
                else getattr(concat_audio, 'bitrate', '192k'),
                logger=self.prog_logger,
            )
            concat_audio.close()
        # Concatenate movie files
        if file_paths[Category.MOVIE] and (
            format is None or format in self._supported_formats[Category.MOVIE]
        ):
            concat_vid = concatenate_videoclips(
                [
                    VideoFileClip(
                        self._join_back(movie_path_set), audio=True, fps_source="tbr"
                    )
                    for movie_path_set in file_paths[Category.MOVIE]
                ],
                method="compose",
            )
            format = "mp4" if format is None else format
            video_out_path = os.path.join(self.output, f"concatenated_video.{format}")
            concat_vid.write_videofile(
                video_out_path,
                fps=concat_vid.fps if self.framerate is None else concat_vid.fps,
                codec=self._supported_formats[Category.MOVIE][format],
                logger=self.prog_logger,
            )
            concat_vid.close()
        # Concatenate image files (make a gif out of them)
        if file_paths[Category.IMAGE] and (
            format is None or format in self._supported_formats[Category.IMAGE]
        ):
            gif_out_path = os.path.join(self.output, "concatenated_image.gif")
            concatenated_image = clips_array(
                [
                    [ImageClip(self._join_back(image_path_set)).set_duration(1)]
                    for image_path_set in file_paths[Category.IMAGE]
                ]
            )
            concatenated_image.write_gif(gif_out_path, fps=self.framerate, logger=self.prog_logger)

        for category in file_paths.keys():
            for i, file_path in enumerate(file_paths[category]):
                self._post_process(
                    file_path, self.output, self.delete, show_status=(i == 0)
                )
        self.event_logger.info("[+] Concatenation completed")

    def merge(self, file_paths: dict, across: bool = False) -> None:
        # For movie files and equally named audio file, merge them together under same name
        # (movie with audio with '_merged' addition to name)
        # If only a video file is provided, look for a matching audio file in the same directory
        found_audio = False
        audio_exts = list(self._supported_formats[Category.AUDIO].keys())

        for movie_path_set in file_paths[Category.MOVIE]:
            # Try to find a corresponding audio file in the input set
            # (e.g. "-1 path1 -2 path2 -n pathn")
            if across:
                # Allow matching audio from any input directory
                audio_fit = next(
                    (
                        audio_set
                        for audio_set in file_paths[Category.AUDIO]
                        if audio_set[1] == movie_path_set[1]
                    ),
                    None,
                )
            else:
                # Only match audio from the same directory as the video
                audio_fit = next(
                    (
                        audio_set
                        for audio_set in file_paths[Category.AUDIO]
                        if audio_set[1] == movie_path_set[1] and audio_set[0] == movie_path_set[0]
                    ),
                    None,
                )

            # If not found, look for a matching audio file in the video's directory
            if audio_fit is None:
                video_dir = movie_path_set[0]
                video_basename = movie_path_set[1]
                for ext in audio_exts:
                    candidate = os.path.join(video_dir, f"{video_basename}.{ext}")
                    if os.path.isfile(candidate):
                        audio_fit = (video_dir, video_basename, ext)
                        break

            if audio_fit is not None:
                found_audio = True
                # Merge movie and audio file
                audio = None
                video = None
                try:
                    video = VideoFileClip(self._join_back(movie_path_set))
                    audio = AudioFileClip(self._join_back(audio_fit))
                    video = video.set_audio(audio)
                    merged_out_path = os.path.join(
                        self.output, f"{movie_path_set[1]}_merged.{movie_path_set[2]}"
                    )
                    video.write_videofile(
                        merged_out_path,
                        fps=video.fps if self.framerate is None else self.framerate,
                        codec=self._supported_formats[Category.MOVIE][movie_path_set[2]],
                        logger=self.prog_logger,
                    )
                finally:
                    if audio is not None:
                        audio.close()
                    if video is not None:
                        video.close()
                self._post_process(movie_path_set, merged_out_path, self.delete)
                # Only delete the audio file if it was in the input set, not if just found in dir
                if audio_fit in file_paths[Category.AUDIO]:
                    self._post_process(audio_fit, merged_out_path, self.delete, show_status=False)
            
        if not found_audio:
            self.event_logger.warning("[!] No audio files found to merge with movie files")


    def _post_process(
        self,
        file_path_set: tuple,
        out_path: str,
        delete: bool,
        show_status: bool = True,
    ) -> None:
        # Post process after conversion, print, delete source file if desired
        if show_status:
            self.event_logger.info(
                f'[+] Converted "{self._join_back(file_path_set)}" to "{out_path}"'
            )
        if delete:
            os.remove(self._join_back(file_path_set))
            self.event_logger.info(
                f'[-] Removed "{self._join_back(file_path_set)}"'
            )

    def _join_back(self, file_path_set: tuple) -> str:
        # Join back the file path set to a concurrent path
        return os.path.abspath(
            f"{file_path_set[0]}{file_path_set[1]}.{file_path_set[2]}"
        )


if __name__ == "__main__":
    # An object is interacted with through a CLI-interface
    # Check if required libraries are installed
    for lib in ["moviepy", "PIL"]:
        try:
            __import__(lib)
        except ImportError as ie:
            print(f"Please install {lib}: {ie}")
            exit(1)

    any_to_any = AnyToAny()

    parser = argparse.ArgumentParser(
        description="Convert media files to different media formats"
    )
    parser.add_argument(
        "-i",
        "--input",
        nargs="+",
        help="Directory containing media files to be converted, Working Directory if none provided",
        type=str,
        required=False,
    )
    parser.add_argument(
        "-o",
        "--output",
        help="Directory to save files, writing to mp4 path if not provided",
        type=str,
        required=False,
    )
    parser.add_argument(
        "-f",
        "--format",
        help=f"Set the output format ({', '.join(any_to_any.supported_formats)})",
        type=str,
        required=False,
    )
    parser.add_argument(
        "-m",
        "--merge",
        help="Per movie file, merge to movie with equally named audio file",
        action="store_true",
        required=False,
    )
    parser.add_argument(
        "-c",
        "--concat",
        help="Concatenate files of same type (img/movie/audio) back to back",
        action="store_true",
        required=False,
    )
    parser.add_argument(
        "-fps",
        "--framerate",
        help="Set the output framerate (default: same as input)",
        type=int,
        required=False,
    )
    parser.add_argument(
        "-q",
        "--quality",
        help="Set the output quality (high, medium, low)",
        type=str,
        required=False,
    )
    parser.add_argument(
        "-d",
        "--delete",
        help="Delete mp4 files after conversion",
        action="store_true",
        required=False,
    )
    parser.add_argument(
        "-w",
        "--web",
        help="Ignores all other arguments, starts web server + frontend",
        action="store_true",
        required=False,
    )
    parser.add_argument(
        "-a",
        "--across",
        help="Execute merging or concatenation across all input directories, not per each individually",
        action="store_true",
        required=False,
    )
    parser.add_argument(
        "-r",
        "--recursive",
        help="Recursively search for files in subdirectories for input",
        action="store_true",
        required=False,
    )
    parser.add_argument(
        "-z",
        "--dropzone",
        help="Dropzone for files to be converted, input dir will be used, distinct output dir has to be specified",
        action="store_true",
        required=False,
    )

    args = vars(parser.parse_args())

    if args["web"]:
        # Check for web frontend request
        if os.name in ["nt"]:
            subprocess.run("python ./web_to_any.py", shell=True)
        else:
            subprocess.run("python3 ./web_to_any.py", shell=True)
    else:
        # Run main function with parsed arguments
        any_to_any.run(
            input_path_args=args["input"],
            format=args["format"],
            output=args["output"],
            framerate=args["framerate"],
            quality=args["quality"],
            merge=args["merge"],
            concat=args["concat"],
            delete=args["delete"],
            across=args["across"],
            recursive=args["recursive"],
            dropzone=args["dropzone"],
        )



================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
apps.mk2112@gmail.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.



================================================
FILE: launcher.py
================================================
#!/usr/bin/env python
import sys
from any_to_any import main

if __name__ == "__main__":
    # -w flag starts executables directly into web view
    sys.argv.append("-w")
    main()



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 MK2112

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: requirements.txt
================================================
flask==3.0.0
flask-reuploaded==1.4.0
jinja2==3.1.2
moviepy==2.1.2
pillow==10.1.0
werkzeug==3.0.1
pypdf2==3.0.1
pymupdf==1.24.9
watchdog
numpy
tqdm


================================================
FILE: web_to_any.py
================================================
import os
import shutil
import tempfile
import webbrowser
from any_to_any import AnyToAny
from flask import Flask, render_template, request, send_file, Response
from flask_uploads import UploadSet, configure_uploads, ALL

"""
Web server providing a web interface as extension to the CLI-based any_to_any.py
"""

app = Flask(__name__, template_folder=os.path.abspath("templates"))
host = "127.0.0.1"
port = 5000
any_to_any = AnyToAny()
any_to_any.web_flag = True
any_to_any.web_host = f'{"http" if host.lower() in ["127.0.0.1", "localhost"] else "https"}://{host}:{port}'

files = UploadSet("files", ALL)
app.config["UPLOADED_FILES_DEST"] = "./uploads"
app.config["CONVERTED_FILES_DEST"] = "./converted"
configure_uploads(app, files)

with app.app_context():
    # This is intended to help allocate memory early
    _ = any_to_any.supported_formats

def push_zip(cv_dir: str) -> Response:
    # Check if cv_dir is empty
    if len(os.listdir(cv_dir)) == 0:
        return Response("No files to convert", status=100)
    # Create a temporary dir for zip file
    temp_dir = tempfile.mkdtemp()
    zip_filename = os.path.join(temp_dir, "converted_files.zip")
    # Zip all files in the 'converted' directory and save it in the temporary directory
    shutil.make_archive(zip_filename[:-4], "zip", cv_dir)
    shutil.rmtree(cv_dir)  # Clean up 'converted' dir
    return send_file(zip_filename, as_attachment=True)  # Return zip file

def process_params() -> tuple:
    uploaded_files = request.files.getlist("files")
    format = request.form.get("conversionType")
    # Achieve some convert-session specificity; 4 Bytes = 8 chars (collision within 26^8 is unlikely)
    conv_key: str = os.urandom(4).hex()
    # These are necessary because uploaded files are 'dumped' in there; Names may collide because of this, so we separate them from beginning
    up_dir: str = f'{app.config["UPLOADED_FILES_DEST"]}_{conv_key}'  # separate upload directories for each conversion session
    cv_dir: str = f'{app.config["CONVERTED_FILES_DEST"]}_{conv_key}'  # separate converted directories for each conversion session

    if not os.path.exists(up_dir):
        os.makedirs(up_dir)
    if not os.path.exists(cv_dir):
        os.makedirs(cv_dir)

    for file in uploaded_files:
        if file:
            filename = os.path.join(up_dir, file.filename)
            file.save(filename)
    # File format to convert to
    return format, up_dir, cv_dir

@app.route("/")
def index():
    return render_template("index.html", title="Any_To_Any.py", options=any_to_any.supported_formats)


def send_to_backend(
    input_path_args: list,
    format: str,
    output: str,
    framerate: int,
    quality: str,
    merge: bool,
    concat: bool,
) -> None:
    # A bit hacky, centralized point to talk to any_to_any.py backend
    # Layed out like this and not just run(args) because we want to meddle with the args here too
    any_to_any.run(
        input_path_args=input_path_args,
        format=format,
        output=output,
        framerate=framerate,
        quality=quality,
        merge=merge,
        concat=concat,
        delete=True,
        across=False,
        recursive=False,
        dropzone=False,
    )
    # Remove upload dir and contents therein
    if len(input_path_args[0]) > 0:
        shutil.rmtree(input_path_args[0])

@app.route("/convert", methods=["POST"])
def convert():
    format, up_dir, cv_dir = process_params()
    # Convert all files uploaded to the 'uploads' directory and save it in the 'converted' directory
    send_to_backend(
        input_path_args=[up_dir],
        format=format,
        output=cv_dir,
        framerate=None,
        quality=None,
        merge=None,
        concat=None,
    )
    return push_zip(cv_dir)


@app.route("/merge", methods=["POST"])
def merge():
    _, up_dir, cv_dir = process_params()
    # Merge all files in the 'uploads' directory and save it in the 'converted' directory
    send_to_backend(
        input_path_args=[up_dir],
        format=None,
        output=cv_dir,
        framerate=None,
        quality=None,
        merge=True,
        concat=None,
    )
    return push_zip(cv_dir)


@app.route("/concat", methods=["POST"])
def concat():
    _, up_dir, cv_dir = process_params()
    # Concatenation is always done with the same format, we just don't explicitly care here which format that is
    send_to_backend(
        input_path_args=[up_dir],
        format=None,
        output=cv_dir,
        framerate=None,
        quality=None,
        merge=None,
        concat=True,
    )
    return push_zip(cv_dir)


if __name__ == "__main__":
    webbrowser.open(any_to_any.web_host)
    app.run(debug=False, host=host, port=port)




================================================
FILE: modules/category.py
================================================
from enum import Enum

class Category(Enum):
    AUDIO = "audio"
    IMAGE = "image"
    MOVIE = "movie"
    DOCUMENT = "document"
    MOVIE_CODECS = "movie_codecs"
    PROTOCOLS = "protocols"


================================================
FILE: modules/prog_logger.py
================================================
import time
from tqdm import tqdm
from proglog import ProgressBarLogger

class ProgLogger(ProgressBarLogger):
    """ Custom logger extracting progress info from moviepy video processing operations"""
    def __init__(self):
        super().__init__()
        self.start_time, self.last_print_time = None, None
        self.print_interval = 0.1  # Frequency of progress updates
        self.tqdm_bar = None

    def bars_callback(self, bar, attr, value, old_value=None):
        if bar == 'chunk' and attr == 'index':
            if self.start_time is None:
                self.start_time = time.time()
                self.last_print_time = self.start_time
                total = self.bars[bar]['total']
                self.tqdm_bar = tqdm(total=total, desc="Processing", unit="chunks")

            # Update our replacing tqdm bar
            # Kind of nonsensical at this point, but we now got the progress info
            if value > (old_value or 0):
                self.tqdm_bar.update(value - (old_value or 0))

            # Handle bar completion
            if value == self.bars[bar]['total']:
                self.tqdm_bar.close()
                #print(f"Processing complete! Time elapsed: {time.time() - self.start_time:.2f}s")



================================================
FILE: modules/watchdog_handler.py
================================================
from watchdog.events import FileSystemEventHandler

class WatchDogFileHandler(FileSystemEventHandler):
    def __init__(self, inner):
        self.inner = inner

    def on_created(self, event):
        if event.is_directory:
            return
        file_path = event.src_path
        # log with the inner’s logger, and trigger its run()
        self.inner.event_logger.info(f"[+] New file detected in dropzone: {file_path}")
        self.inner.run([file_path],
                    format=self.inner.format,
                    output=self.inner.output,
                    framerate=self.inner.framerate,
                    quality=self.inner.quality,
                    merge=self.inner.merging,
                    concat=self.inner.concatenating,
                    delete=self.inner.delete,
                    across=self.inner.across,
                    recursive=self.inner.recursive,
                    dropzone=False)


================================================
FILE: static/css/style.css
================================================
body {
    margin-left: 0;
    margin-right: 0;
    margin-top: 0;
    font-size: large;
    background-color: white;
    font-family: ui-sans-serif, Segoe UI, Helvetica Neue, Roboto, Arial, sans-serif;
}

@media (prefers-color-scheme: dark) {
    body {
        background-color: #151515;
        color: whitesmoke;
    }

    .static-anchor {
        color: whitesmoke !important;
    }

    #drop-area:hover {
        background-color: #252525 !important;
    }
}

h1 p {
    display: inline-block;
    font-weight: 100;
    margin: 0;
}

header {
    display: flex;
    justify-content: space-between;
    width: auto;
    margin-top: 5%;
}

html, body {
    height: 90%;
}

.fade-in {
    animation: fade-in 0.75s forwards;
    height: 80%;
}

.static-anchor {
    text-decoration: none;
    color: black;
}

@keyframes fade-in {
    from {
        opacity: 0;
    }

    to {
        opacity: 1;
    }
}


@media only screen and (max-width: 799px) {
    .fade-in {
        margin-left: 2%;
        margin-right: 2%;
    }

    header {
        margin-left: 2%;
        margin-right: 2%;
    }
}

@media only screen and (min-width: 800px) and (max-width: 999px) {
    .fade-in {
        margin-left: 10%;
        margin-right: 10%;
    }

    header {
        margin-left: 10%;
        margin-right: 10%;
    }
}

@media only screen and (min-width: 1000px) {
    .fade-in {
        margin-left: 27%;
        margin-right: 27%;
    }

    header {
        margin-left: 27%;
        margin-right: 27%;
    }
}

#drop-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    border: 1px dashed #ccc;
    border-radius: 8px;
    text-align: center;
    padding: 50px;
    cursor: pointer;
    box-sizing: border-box;
    transition: 0.3s ease-in-out;
}

#drop-area:hover {
    background-color: #f5f5f5;
    border: 1px dashed #bbb;
}

main, form, #drop-area {
    height: 80%;
}

#file-list {
    list-style-type: none;
    padding: 0;
    font-size: 0.75rem;
}

#conversion-options {
    margin-top: 20px;
}

.no-script {
    text-align: center;
    padding: 20px; 
    background-color: #f44336; 
    color: white;
    border-radius: 5px;
    margin-bottom: 10px;
}

.loader {
    display: none;
    border: 6px solid #f3f3f3;
    border-top: 6px solid #4F4F4F;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1.25s linear infinite;
    margin-left: auto;
    margin-right: auto;
    margin-top: -10%;
    margin-bottom: auto;
    z-index: 1000;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}


================================================
FILE: static/js/main.js
================================================
// Accumulate all selected/dropped files in this array
let uploadedFiles = [];

function submitForm(endpoint) {
    const conversionType = document.getElementById('conversion-type').value;
    
    if (uploadedFiles.length === 0) {
        alert('No files selected!');
        return;
    }

    // Build FormData from our global array
    // Basis for formulating POST request
    const form_data = new FormData();
    // Append each file to the FormData object
    uploadedFiles.forEach(file => form_data.append('files', file));
    // Append the conversion type to the FormData object
    form_data.append('conversionType', conversionType);

    const xhr = new XMLHttpRequest();
    // Hand off the FormData to the server
    xhr.open('POST', endpoint, true);
    // loader animation for the user during processing
    showLoader();

    xhr.onload = function () {
        hideLoader();
        // If successful, the server should return a zip file
        // We hand that off to the browser to download
        if (xhr.status === 200) {
            const blob = new Blob([xhr.response], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            const timestamp = new Date().toISOString().replace(/[-T:Z]/g, '');
            link.download = `any_to_any-${timestamp}.zip`;
            link.click();
        } else {
            alert('Error Uploading Files.');
        }
    };

    xhr.onerror = function () {
        hideLoader();
        alert('Conversion Failed. Provided File May Be Corrupted/Incomplete or Upload Failed.');
    };

    xhr.responseType = 'arraybuffer';
    xhr.send(form_data);

    // Reset state
    uploadedFiles = [];
    document.getElementById('file-list').innerHTML = '';
}

function triggerUploadDialogue(event) {
    // Trigger the file input click when the drop area is clicked
    // This allows the user to select files from their file system
    // with a button click additionally to drag and drop
    if (event.target.tagName !== 'INPUT') {
        document.getElementById('files').click();
    }
}

function allowDrop(event) {
    // Allow dropping files into the drop area
    event.preventDefault();
}

function drop(event) {
    // Prevent file from being opened
    event.preventDefault();
    handleFiles(event.dataTransfer.files, false);
}

function handleFiles(files, fromInput) {
    // If files come from the <input>, replace entire array; on drop, append
    if (fromInput) {
        uploadedFiles = Array.from(files);
    } else {
        // Append new files, avoid exact duplicates by name+size
        Array.from(files).forEach(f => {
            if (!uploadedFiles.some(existing => existing.name === f.name && existing.size === f.size)) {
                uploadedFiles.push(f);
            }
        });
    }

    // Update visible file list
    const fileList = document.getElementById('file-list');
    fileList.innerHTML = '';
    // Show the names of the files selected in the drop area
    uploadedFiles.forEach(f => {
        const li = document.createElement('li');
        li.textContent = f.name;
        fileList.appendChild(li);
    });
}

// Show the loader animation
function showLoader() {
    document.getElementById('loader').style.display = 'block';
}

// Hide the loader animation
function hideLoader() {
    document.getElementById('loader').style.display = 'none';
}

// Wiring up the <input> change to our handler
document.getElementById('files').addEventListener('change', function() {
    handleFiles(this.files, true);
});



================================================
FILE: templates/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>
    <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>
<body>
    <header>
        <h1>
            <a class="static-anchor" target="_blank" href="https://github.com/mk2112/any_to_any.py">{{ title }}</a>
            <p>Web</p>
            <a class="github-button" href="https://github.com/mk2112/any_to_any.py/fork" data-icon="octicon-repo-forked" aria-label="Fork mk2112/any_to_any.py on GitHub">Fork</a>
            <a class="github-button" href="https://github.com/mk2112/any_to_any.py" data-icon="octicon-star" aria-label="Star mk2112/any_to_any.py on GitHub">Star</a>
        </h1>
    </header>
    <div class="fade-in">
        <main>
            <noscript>
                <div class="no-script">
                    <p><code>{{ title }} Web</code> requires <code>JavaScript</code> to work as intended.</p>
                    <p>Please enable <code>JavaScript</code> in your browser settings.</p>
                </div>
            </noscript>
            <form id="conversion-form" method="post" enctype="multipart/form-data">
                <div id="drop-area" ondrop="drop(event)" ondragover="allowDrop(event)" onclick="triggerUploadDialogue(event)">
                    <p>Drag and drop or click to select files</p>
                    <input type="file" name="files" id="files" multiple onchange="handleFiles(this.files, true)">
                    <ul id="file-list"></ul>
                </div>
                <div id="conversion-options">
                    <label for="conversion-type">Convert to:</label>
                    <select id="conversion-type">
                        {% for option in options %}
                        <option value="{{ option }}">{{ option }}</option>
                        {% endfor %}
                    </select>
                    <button title="Convert All Given Files To Selected Format" type="button" onclick="submitForm('/convert')">Convert</button>
                    <button title="Merge Movie Data With The Audio Track Of An Equally Named Audio File" type="button" onclick="submitForm('/merge')">Merge</button>
                    <button title="Glue Files Of Same Type Together, Back To Back, In Above Displayed Order" type="button" onclick="submitForm('/concat')">Concatenate</button>
                </div>
            </form>                    
        </main>
    </div>
    <div class="loader" id="loader"></div>
</body>
</html>


================================================
FILE: tests/__init__.py
================================================




================================================
FILE: tests/test_cli.py
================================================
import pytest
import sys
from tests.test_fixtures import any_to_any_instance

def test_cli_help_output(tmp_path):
    import subprocess
    import os
    script_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'any_to_any.py'))
    result = subprocess.run([sys.executable, script_path, "-h"], capture_output=True, text=True)
    assert "usage" in result.stdout.lower() or "usage" in result.stderr.lower()

def test_cli_invalid_format(tmp_path):
    import subprocess
    result = subprocess.run([sys.executable, "any_to_any.py", "-i", str(tmp_path), "-f", "xyz"], cwd=str(tmp_path.parent), capture_output=True, text=True)
    assert "unsupported format" in result.stdout.lower() or "unsupported format" in result.stderr.lower() or result.returncode != 0

def test_blank_start_no_files_in_cli_output(any_to_any_instance, caplog):
    with caplog.at_level("INFO"):
        any_to_any_instance.run([], None, None, None, None, False, False, False, False, False, False)
    assert "No convertible media files" in caplog.text



================================================
FILE: tests/test_conversion_methods.py
================================================
import pytest
import warnings
from any_to_any import Category
from tests.test_fixtures import any_to_any_instance

def test_to_audio_invalid_format(any_to_any_instance, tmp_path):
    invalid_file = tmp_path / "invalid_file.mp3"
    invalid_file.touch()
    with warnings.catch_warnings():
        warnings.filterwarnings(
            "ignore",
            message=r"Exception ignored in: <function FFMPEG_AudioReader.__del__.*AttributeError: 'FFMPEG_AudioReader' object has no attribute 'proc'",
            category=Warning,
        )
        with pytest.raises((OSError, KeyError)):
            any_to_any_instance.to_audio(file_paths={Category.AUDIO: [((str(tmp_path) + "/"), 'invalid_file', 'mp3')]}, format='invalid_format', codec='libmp3lame')

def test_to_gif_handles_invalid_file(any_to_any_instance, tmp_path):
    fake_file = tmp_path / "fake.mp3"
    fake_file.write_bytes(b"\x00" * 128)
    with pytest.raises(Exception):
        any_to_any_instance.to_gif({'audio': [(str(tmp_path) + "/", 'fake', 'mp3')]}, 'gif')

def test_to_bmp_with_image(any_to_any_instance, tmp_path):
    fake_file = tmp_path / "fake.jpg"
    fake_file.write_bytes(b"\x00" * 128)
    with pytest.raises(Exception):
        any_to_any_instance.to_bmp({'image': [(str(tmp_path) + "/", 'fake', 'jpg')]}, 'bmp')

def test_to_webp_with_image(any_to_any_instance, tmp_path):
    fake_file = tmp_path / "fake.png"
    fake_file.write_bytes(b"\x00" * 128)
    with pytest.raises(Exception):
        any_to_any_instance.to_webp({'image': [(str(tmp_path) + "/", 'fake', 'png')]}, 'webp')

def test_to_frames_with_pdf(any_to_any_instance, tmp_path):
    fake_file = tmp_path / "fake.pdf"
    fake_file.write_bytes(b"%PDF-1.4\n%Fake PDF\n")
    with pytest.raises(Exception):
        any_to_any_instance.to_frames({'document': [(str(tmp_path) + "/", 'fake', 'pdf')]}, 'png')

def test_to_audio_unsupported_format(any_to_any_instance, tmp_path):
    fake_file = tmp_path / "test.wav"
    fake_file.write_bytes(b"\x00" * 128)
    with pytest.raises(Exception):
        any_to_any_instance.to_audio({'audio': [(str(tmp_path) + "/", 'test', 'wav')]}, 'xyz', 'libmp3lame')

def test_to_movie_invalid_codec(any_to_any_instance, tmp_path):
    fake_file = tmp_path / "test.mp4"
    fake_file.write_bytes(b"\x00" * 128)
    with pytest.raises(Exception):
        any_to_any_instance.to_movie({'movie': [(str(tmp_path) + "/", 'test', 'mp4')]}, 'mp4', 'invalid_codec')

def test_to_subtitles_invalid_format(any_to_any_instance, tmp_path):
    fake_file = tmp_path / "test.srt"
    fake_file.write_text("1\n00:00:00,000 --> 00:00:01,000\nHello\n")
    with pytest.raises(Exception):
        any_to_any_instance.to_subtitles({'document': [(str(tmp_path) + "/", 'test', 'srt')]}, 'xyz')



================================================
FILE: tests/test_core.py
================================================
import pytest
from any_to_any import AnyToAny
from tests.test_fixtures import any_to_any_instance, test_input_folder
from modules.category import Category

def test_supported_formats(any_to_any_instance):
    assert isinstance(any_to_any_instance.supported_formats, list)
    assert len(any_to_any_instance.supported_formats) > 0

def test_audio_bitrate(any_to_any_instance):
    assert any_to_any_instance._audio_bitrate('mp3', 'high') == '320k'
    assert any_to_any_instance._audio_bitrate('flac', 'medium') == '320k'
    assert any_to_any_instance._audio_bitrate('ogg', 'low') == '128k'
    assert any_to_any_instance._audio_bitrate('mp3', 'medium') == '192k'
    assert any_to_any_instance._audio_bitrate('invalid_format', 'medium') == '192k'

def test_get_file_paths_valid_input_files(any_to_any_instance, tmp_path):
    movie_path = tmp_path / "test_movie.mp4"
    image_path = tmp_path / "test_image.jpg"
    movie_path.touch()
    image_path.touch()
    file_paths = any_to_any_instance._get_file_paths(input=str(tmp_path))
    assert Category.IMAGE in file_paths
    assert Category.MOVIE in file_paths
    assert len(file_paths[Category.IMAGE]) == 1
    assert len(file_paths[Category.MOVIE]) == 1

def test_join_back_method(any_to_any_instance, test_input_folder):
    file_path_set = ((str(test_input_folder) + "/"), 'test_file', 'mp4')
    assert any_to_any_instance._join_back(file_path_set) == str(test_input_folder / 'test_file.mp4')



================================================
FILE: tests/test_edge_cases.py
================================================
import pytest
from tests.test_fixtures import any_to_any_instance
from unittest.mock import patch

def test_empty_directory(any_to_any_instance, tmp_path):
    empty_dir = tmp_path / "empty"
    empty_dir.mkdir()
    with pytest.raises(SystemExit):
        any_to_any_instance.run([str(empty_dir)], format="mp3", output=str(tmp_path), framerate=None, quality=None, merge=False, concat=False, delete=False, across=False, recursive=False, dropzone=False)

def test_permission_error_on_output(any_to_any_instance, tmp_path):
    file_path = tmp_path / "test.mp4"
    file_path.write_bytes(b"\x00" * 128)
    with patch("os.remove", side_effect=PermissionError):
        with pytest.raises(PermissionError):
            any_to_any_instance._post_process((str(tmp_path) + "/", 'test', 'mp4'), str(tmp_path / "out.mp3"), delete=True)

def test_get_file_paths_invalid_directory(any_to_any_instance):
    with pytest.raises(FileNotFoundError):
        any_to_any_instance._get_file_paths(input="nonexistent_directory")

def test_fuzz_random_file_names(any_to_any_instance, tmp_path):
    import random
    import string
    for _ in range(10):
        name = ''.join(random.choices(string.ascii_letters, k=8))
        ext = random.choice(['mp4', 'mp3', 'jpg', 'wav', 'pdf'])
        file = tmp_path / f"{name}.{ext}"
        file.write_bytes(b"\x00" * 128)
    try:
        any_to_any_instance._get_file_paths(str(tmp_path))
    except Exception as e:
        pytest.fail(f"_get_file_paths failed: {e}")



================================================
FILE: tests/test_fixtures.py
================================================
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import pytest
import tempfile
import shutil
from any_to_any import AnyToAny

@pytest.fixture
def temp_media_dir(tmp_path):
    media_dir = tmp_path / "media"
    media_dir.mkdir()
    (media_dir / "test.mp4").write_bytes(b"\x00" * 128)
    (media_dir / "test.mp3").write_bytes(b"\x00" * 128)
    (media_dir / "test.jpg").write_bytes(b"\x00" * 128)
    (media_dir / "test.txt").write_text("not a media file")
    return media_dir

@pytest.fixture
def test_input_folder(tmp_path):
    test_folder = tmp_path / "test_input"
    test_folder.mkdir()
    return test_folder

@pytest.fixture
def test_output_folder(tmp_path):
    test_folder = tmp_path / "test_output"
    test_folder.mkdir()
    return test_folder

@pytest.fixture
def any_to_any_instance():
    return AnyToAny()



================================================
FILE: tests/test_integration_and_routing.py
================================================
import pytest
import sys
import os
import argparse
from unittest import mock
from any_to_any import AnyToAny
from modules.category import Category
import types

@pytest.fixture
def instance():
    return AnyToAny()

def test_routing_supported_formats(instance):
    """
    Ensure all supported formats are routed to the correct handler or codec.
    """
    for cat, formats in instance._supported_formats.items():
        for fmt, handler in formats.items():
            if callable(handler):
                # Should call the handler without error (mock file_paths)
                with mock.patch.object(instance, handler.__name__, return_value=None) as m:
                    getattr(instance, handler.__name__)({}, fmt)
                    m.assert_called()
            else:
                # Should be a codec string or list
                assert isinstance(handler, (str, list))

def test_run_web_flag_starts_web():
    """
    Test that the CLI parser recognizes the -w/--web flag.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-w', '--web', action='store_true')
    args = parser.parse_args(['-w'])
    assert args.web


def test_end_with_msg_logs_and_exits(instance, caplog):
    """
    Test _end_with_msg logs error and raises SystemExit.
    """
    with caplog.at_level('WARNING'):
        with pytest.raises(SystemExit):
            instance._end_with_msg(SystemExit, 'fail message')
    assert 'fail message' in caplog.text

def test_recursive_file_discovery(instance, tmp_path):
    """
    _get_file_paths does not recurse; only top-level files are found.
    """
    d1 = tmp_path / "a"
    d2 = d1 / "b"
    d2.mkdir(parents=True)
    f = d2 / "test.mp4"
    f.write_bytes(b"\x00"*128)
    file_paths = instance._get_file_paths(str(tmp_path))
    # Should NOT find nested files
    found = any(
        str(f.parent) in path[0] and path[1] == 'test' and path[2] == 'mp4'
        for paths in file_paths.values() for path in paths
    )
    assert not found  # Documented limitation


def test_weird_filenames(instance, tmp_path):
    """
    Test handling of files with unicode and special chars in names.
    """
    fname = "weird_名字_#@!.mp3"
    f = tmp_path / fname
    f.write_bytes(b"\x00"*128)
    file_paths = instance._get_file_paths(str(tmp_path))
    found = any(fname[:-4] in path[1] for paths in file_paths.values() for path in paths)
    assert found

def test_post_process_permission_error(instance, tmp_path):
    """
    Test _post_process logs and raises on permission error during delete.
    """
    f = tmp_path / "test.mp4"
    f.write_bytes(b"\x00"*128)
    with mock.patch("os.remove", side_effect=PermissionError):
        with pytest.raises(PermissionError):
            instance._post_process((str(tmp_path) + "/", 'test', 'mp4'), str(tmp_path / "out.mp3"), delete=True)




================================================
FILE: tests/test_logging_progress.py
================================================
import pytest
from tests.test_fixtures import any_to_any_instance

def test_logging_and_progress(any_to_any_instance, caplog):
    with caplog.at_level("INFO"):
        any_to_any_instance.event_logger.info("Test log message")
    assert any("Test log message" in r.getMessage() for r in caplog.records)



================================================
FILE: tests/test_merge_concat.py
================================================
import pytest
from tests.test_fixtures import any_to_any_instance, test_input_folder, test_output_folder
from modules.category import Category

def test_merging_method(any_to_any_instance, test_input_folder, test_output_folder):
    movie_path = test_input_folder / "movie_name.mp4"
    audio_path = test_input_folder / "movie_name.mp3"
    movie_path.touch()
    audio_path.touch()
    with pytest.raises(OSError):
        any_to_any_instance.merge({
            Category.MOVIE: [((str(movie_path.parent) + "/"), 'movie_name', 'mp4')],
            Category.AUDIO: [((str(audio_path.parent) + "/"), 'movie_name', 'mp3')]
        })

def test_concatenating_method(any_to_any_instance, test_input_folder, test_output_folder):
    movie1_path = test_input_folder / "movie1.mp4"
    movie2_path = test_input_folder / "movie2.mp4"
    movie1_path.touch()
    movie2_path.touch()
    with pytest.raises(OSError):
        any_to_any_instance.concat({
            Category.AUDIO: [],
            Category.MOVIE: [((str(movie1_path.parent) + "/"), 'movie1', 'mp4'), ((str(movie2_path.parent) + "/"), 'movie2', 'mp4')]
        }, format="mp4")



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



================================================
FILE: .github/workflows/test.yml
================================================
name: Run Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.12'
    - name: Install ffmpeg
      run: sudo apt-get update && sudo apt-get install -y ffmpeg
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest
    - name: List installed packages
      run: pip list
    - name: Run tests
      run: |
        python -m pytest ./tests

